/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       C:\Users\satya                                            */
/*    Created:      Tue Sep 15 2020                                           */
/*    Description:  V5 project                                                */
/*                                                                            */
/*----------------------------------------------------------------------------*/

// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Vision15             vision        15              
// ---- END VEXCODE CONFIGURED DEVICES ----

#include "vex.h"
#include "VisionSensor.h"

using namespace vex;

vex::brain Brain;
vex::competition Competition;

//motors, PORTS WILL CHANGE
vex::motor RightMotor = vex::motor(vex::PORT8);
vex::motor LeftMotor = vex::motor(vex::PORT9, true);
vex::motor MiddleMotor = vex::motor(vex::PORT7);
vex::motor bottomMotorSpin = vex::motor(vex::PORT20);
vex::motor frontMotorBottom = vex::motor(vex::PORT18);
vex::motor backMotorTop = vex::motor(vex::PORT19);
vex::motor rightClaw = vex::motor(vex::PORT5);
vex::motor leftClaw = vex::motor(vex::PORT6);

vex::controller Controller1 = vex::controller();

int exp_value = 1;
void autonomous (void) {

}

void usercontrol (void) {
  while(1){
    

//Basic movement controls
    RightMotor.spin(vex::directionType::fwd, 127*((exp_value)^Controller1.Axis2.position()), vex::velocityUnits::pct);
    LeftMotor.spin(vex::directionType::fwd, 127*((exp_value)^Controller1.Axis3.position()), vex::velocityUnits::pct);
    if(Controller1.ButtonDown.pressing()){
      MiddleMotor.spin(vex::directionType::fwd, 127, vex::velocityUnits::pct);
    }
    else if(Controller1.ButtonB.pressing()){
      MiddleMotor.spin(vex::directionType::rev, 127, vex::velocityUnits::pct);
    }
    else{
      MiddleMotor.stop(vex::brakeType::brake);
    }

//claw movement
    if(Controller1.ButtonR2.pressing()){
      rightClaw.spin(vex::directionType::fwd, 127, vex::velocityUnits::pct);
    }
    else{
      rightClaw.stop(vex::brakeType::brake);
    }
    
    if(Controller1.ButtonL2.pressing()){
      leftClaw.spin(vex::directionType::fwd, 127, vex::velocityUnits::pct);
    }
    else{
      leftClaw.stop(vex::brakeType::brake);
    }

//multi commands
    
    //bring the balls up
    if(Controller1.ButtonA.pressing()){
      frontMotorBottom.spin(vex::directionType::rev, 127, vex::velocityUnits::pct);
      bottomMotorSpin.spin(vex::directionType::fwd, 127, vex::velocityUnits::pct);
      backMotorTop.spin(vex::directionType::fwd, 127, vex::velocityUnits::pct);
    }
    else{
      frontMotorBottom.stop(vex::brakeType::brake);
      bottomMotorSpin.stop(vex::brakeType::brake);
      backMotorTop.stop(vex::brakeType::brake);
    }

    //bring balls down
    if(Controller1.ButtonA.pressing()){
      frontMotorBottom.spin(vex::directionType::fwd, 127, vex::velocityUnits::pct);
      bottomMotorSpin.spin(vex::directionType::rev, 127, vex::velocityUnits::pct);
      backMotorTop.spin(vex::directionType::rev, 127, vex::velocityUnits::pct);
    }
    else{
      frontMotorBottom.stop(vex::brakeType::brake);
      bottomMotorSpin.stop(vex::brakeType::brake);
      backMotorTop.stop(vex::brakeType::brake);
    }

    //Get rid of ball override function
    if(Controller1.ButtonX.pressing()){
      bottomMotorSpin.spin(vex::directionType::fwd, 127, vex::velocityUnits::pct);
      backMotorTop.spin(vex::directionType::rev, 127, vex::velocityUnits::pct);
      vex::task::sleep(50);
      bottomMotorSpin.stop(vex::brakeType::brake);
      backMotorTop.stop(vex::brakeType::brake);
    }

//color sensor to kick ball out
    vex::task::sleep(50);
  }
}

int main() {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();

  Competition.autonomous( autonomous );
  Competition.drivercontrol(usercontrol);
  
  while(1){
    vex::task::sleep(200);
  }
}
